{
	"ast": null,
	"code": "export default \"\\n/*!\\n * Signature Pad v3.0.0-beta.3 | https://github.com/szimek/signature_pad\\n * (c) 2018 Szymon Nowak | Released under the MIT license\\n */\\n\\n(function (global, factory) {\\n  typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() :\\n  typeof define === 'function' && define.amd ? define(factory) :\\n  (global.SignaturePad = factory());\\n}(this, (function () { 'use strict';\\n\\n  var Point = (function () {\\n      function Point(x, y, time) {\\n          this.x = x;\\n          this.y = y;\\n          this.time = time || Date.now();\\n      }\\n      Point.prototype.distanceTo = function (start) {\\n          return Math.sqrt(Math.pow(this.x - start.x, 2) + Math.pow(this.y - start.y, 2));\\n      };\\n      Point.prototype.equals = function (other) {\\n          return this.x === other.x && this.y === other.y && this.time === other.time;\\n      };\\n      Point.prototype.velocityFrom = function (start) {\\n          return this.time !== start.time\\n              ? this.distanceTo(start) / (this.time - start.time)\\n              : 0;\\n      };\\n      return Point;\\n  }());\\n\\n  var Bezier = (function () {\\n      function Bezier(startPoint, control2, control1, endPoint, startWidth, endWidth) {\\n          this.startPoint = startPoint;\\n          this.control2 = control2;\\n          this.control1 = control1;\\n          this.endPoint = endPoint;\\n          this.startWidth = startWidth;\\n          this.endWidth = endWidth;\\n      }\\n      Bezier.fromPoints = function (points, widths) {\\n          var c2 = this.calculateControlPoints(points[0], points[1], points[2]).c2;\\n          var c3 = this.calculateControlPoints(points[1], points[2], points[3]).c1;\\n          return new Bezier(points[1], c2, c3, points[2], widths.start, widths.end);\\n      };\\n      Bezier.calculateControlPoints = function (s1, s2, s3) {\\n          var dx1 = s1.x - s2.x;\\n          var dy1 = s1.y - s2.y;\\n          var dx2 = s2.x - s3.x;\\n          var dy2 = s2.y - s3.y;\\n          var m1 = { x: (s1.x + s2.x) / 2.0, y: (s1.y + s2.y) / 2.0 };\\n          var m2 = { x: (s2.x + s3.x) / 2.0, y: (s2.y + s3.y) / 2.0 };\\n          var l1 = Math.sqrt(dx1 * dx1 + dy1 * dy1);\\n          var l2 = Math.sqrt(dx2 * dx2 + dy2 * dy2);\\n          var dxm = m1.x - m2.x;\\n          var dym = m1.y - m2.y;\\n          var k = l2 / (l1 + l2);\\n          var cm = { x: m2.x + dxm * k, y: m2.y + dym * k };\\n          var tx = s2.x - cm.x;\\n          var ty = s2.y - cm.y;\\n          return {\\n              c1: new Point(m1.x + tx, m1.y + ty),\\n              c2: new Point(m2.x + tx, m2.y + ty)\\n          };\\n      };\\n      Bezier.prototype.length = function () {\\n          var steps = 10;\\n          var length = 0;\\n          var px;\\n          var py;\\n          for (var i = 0; i <= steps; i += 1) {\\n              var t = i / steps;\\n              var cx = this.point(t, this.startPoint.x, this.control1.x, this.control2.x, this.endPoint.x);\\n              var cy = this.point(t, this.startPoint.y, this.control1.y, this.control2.y, this.endPoint.y);\\n              if (i > 0) {\\n                  var xdiff = cx - px;\\n                  var ydiff = cy - py;\\n                  length += Math.sqrt(xdiff * xdiff + ydiff * ydiff);\\n              }\\n              px = cx;\\n              py = cy;\\n          }\\n          return length;\\n      };\\n      Bezier.prototype.point = function (t, start, c1, c2, end) {\\n          return (start * (1.0 - t) * (1.0 - t) * (1.0 - t))\\n              + (3.0 * c1 * (1.0 - t) * (1.0 - t) * t)\\n              + (3.0 * c2 * (1.0 - t) * t * t)\\n              + (end * t * t * t);\\n      };\\n      return Bezier;\\n  }());\\n\\n  function throttle(fn, wait) {\\n      if (wait === void 0) { wait = 250; }\\n      var previous = 0;\\n      var timeout = null;\\n      var result;\\n      var storedContext;\\n      var storedArgs;\\n      var later = function () {\\n          previous = Date.now();\\n          timeout = null;\\n          result = fn.apply(storedContext, storedArgs);\\n          if (!timeout) {\\n              storedContext = null;\\n              storedArgs = [];\\n          }\\n      };\\n      return function wrapper() {\\n          var args = [];\\n          for (var _i = 0; _i < arguments.length; _i++) {\\n              args[_i] = arguments[_i];\\n          }\\n          var now = Date.now();\\n          var remaining = wait - (now - previous);\\n          storedContext = this;\\n          storedArgs = args;\\n          if (remaining <= 0 || remaining > wait) {\\n              if (timeout) {\\n                  clearTimeout(timeout);\\n                  timeout = null;\\n              }\\n              previous = now;\\n              result = fn.apply(storedContext, storedArgs);\\n              if (!timeout) {\\n                  storedContext = null;\\n                  storedArgs = [];\\n              }\\n          }\\n          else if (!timeout) {\\n              timeout = window.setTimeout(later, remaining);\\n          }\\n          return result;\\n      };\\n  }\\n\\n  var SignaturePad = (function () {\\n      function SignaturePad(canvas, options) {\\n          if (options === void 0) options = {};\\n          var _this = this;\\n          this.canvas = canvas;\\n          this.options = options;\\n          this._startingSignature = null;\\n          this._isDrawing = true;\\n          this._history = [];\\n          this._handleMouseDown = function (event) {\\n              if (event.which === 1) {\\n                  _this._mouseButtonDown = true;\\n                  _this._strokeBegin(event);\\n              }\\n          };\\n          this._handleMouseMove = function (event) {\\n              if (_this._mouseButtonDown) {\\n                  _this._strokeMoveUpdate(event);\\n              }\\n          };\\n          this._handleMouseUp = function (event) {\\n              if (event.which === 1 && _this._mouseButtonDown) {\\n                  _this._mouseButtonDown = false;\\n                  _this._strokeEnd(event);\\n              }\\n          };\\n          this._handleTouchStart = function (event) {\\n              event.preventDefault();\\n              if (event.targetTouches.length === 1) {\\n                  var touch = event.changedTouches[0];\\n                  _this._strokeBegin(touch);\\n              }\\n          };\\n          this._handleTouchMove = function (event) {\\n              event.preventDefault();\\n              var touch = event.targetTouches[0];\\n              _this._strokeMoveUpdate(touch);\\n          };\\n          this._handleTouchEnd = function (event) {\\n              var wasCanvasTouched = event.target === _this.canvas;\\n              if (wasCanvasTouched) {\\n                  event.preventDefault();\\n                  var touch = event.changedTouches[0];\\n                  _this._strokeEnd(touch);\\n              }\\n          };\\n          this.velocityFilterWeight = options.velocityFilterWeight || 0.7;\\n          this.minWidth = options.minWidth || 0.5;\\n          this.maxWidth = options.maxWidth || 2.5;\\n          this.throttle = \\\"throttle\\\" in options ? options.throttle : 16;\\n          this.minDistance = \\\"minDistance\\\" in options ? options.minDistance : 5;\\n          this._strokeMoveUpdate = this.throttle\\n            ? (this._strokeMoveUpdate = throttle(\\n                SignaturePad.prototype._strokeUpdate,\\n                this.throttle\\n              ))\\n            : SignaturePad.prototype._strokeUpdate;\\n          this.dotSize = options.dotSize || function dotSize() {return (this.minWidth + this.maxWidth) / 2;};\\n          this.penColor = options.penColor || \\\"black\\\";\\n          this.backgroundColor = options.backgroundColor || \\\"rgba(255,255,255,0)\\\";\\n          this.onBegin = options.onBegin;\\n          this.onEnd = options.onEnd;\\n          this._ctx = canvas.getContext(\\\"2d\\\");\\n          this.clear();\\n          this.on();\\n      }\\n      SignaturePad.prototype.clear = function () {\\n          var ctx = this._ctx;\\n          var canvas = this.canvas;\\n          ctx.fillStyle = this.backgroundColor;\\n          ctx.clearRect(0, 0, canvas.width, canvas.height);\\n          ctx.fillRect(0, 0, canvas.width, canvas.height);\\n          this._data = [];\\n          this._reset();\\n          this._isEmpty = true;\\n      };\\n      SignaturePad.prototype.undo = function () {\\n        const data = this.toData();\\n        if (data && data.length) {\\n            this._history.push(data.pop()); // remove the last stroke\\n        } else if (this._startingSignature) {\\n            return; // they performed undo of background sig\\n        }\\n        this.clear();\\n        if (this._startingSignature) {\\n            this.fromDataURL(this._startingSignature, {}, () => this.fromData(data, true));\\n        } else {\\n            this.fromData(data, true);\\n        }\\n      };\\n      SignaturePad.prototype.redo = function () {\\n        if (!this._history.length) return;\\n        const data = this.toData();\\n        data.push(this._history.pop());\\n        this.clear();\\n        if (this._startingSignature) {\\n            this.fromDataURL(this._startingSignature, {}, () => this.fromData(data, true));\\n        } else {\\n            this.fromData(data, true);\\n        }\\n      };\\n      SignaturePad.prototype.draw = function () {\\n        this._ctx.globalCompositeOperation = \\\"source-over\\\";\\n        this._isDrawing = true;\\n      };\\n      SignaturePad.prototype.erase = function () {\\n        this._ctx.globalCompositeOperation = \\\"destination-out\\\";\\n        this._isDrawing = false;\\n      };\\n      SignaturePad.prototype.fromDataURL = function (dataUrl, options, callback) {\\n          var _this = this;\\n          if (options === void 0) options = {};\\n          var image = new Image();\\n          var ratio = options.ratio || window.devicePixelRatio || 1;\\n          var width = options.width || this.canvas.width / ratio;\\n          var height = options.height || this.canvas.height / ratio;\\n          this._reset();\\n          image.src = dataUrl;\\n          image.onload = function () {\\n            _this._ctx.globalCompositeOperation = \\\"source-over\\\";\\n            _this._ctx.drawImage(image, 0, 0, width, height);\\n            _this._ctx.globalCompositeOperation = _this._isDrawing ? \\\"source-over\\\" : \\\"destination-out\\\";\\n              if (callback) {\\n                  callback();\\n              }\\n          };\\n          image.onerror = function (error) {\\n              if (callback) {\\n                  callback(error);\\n              }\\n          };\\n          this._isEmpty = false;\\n          if (!this._startingSignature) this._startingSignature = dataUrl;\\n      };\\n      SignaturePad.prototype.toDataURL = function (type = \\\"image/png\\\", encoderOptions) {\\n        return type === \\\"image/svg+xml\\\" ? this._toSVG() : this.canvas.toDataURL(type, encoderOptions);\\n      };\\n      SignaturePad.prototype.on = function () {\\n          this.canvas.style.touchAction = 'none';\\n          this.canvas.style.msTouchAction = 'none';\\n          if (window.PointerEvent) {\\n              this._handlePointerEvents();\\n          }\\n          else {\\n              this._handleMouseEvents();\\n              if ('ontouchstart' in window) {\\n                  this._handleTouchEvents();\\n              }\\n          }\\n      };\\n      SignaturePad.prototype.off = function () {\\n          this.canvas.style.touchAction = 'auto';\\n          this.canvas.style.msTouchAction = 'auto';\\n          this.canvas.removeEventListener('pointerdown', this._handleMouseDown);\\n          this.canvas.removeEventListener('pointermove', this._handleMouseMove);\\n          document.removeEventListener('pointerup', this._handleMouseUp);\\n          this.canvas.removeEventListener('mousedown', this._handleMouseDown);\\n          this.canvas.removeEventListener('mousemove', this._handleMouseMove);\\n          document.removeEventListener('mouseup', this._handleMouseUp);\\n          this.canvas.removeEventListener('touchstart', this._handleTouchStart);\\n          this.canvas.removeEventListener('touchmove', this._handleTouchMove);\\n          this.canvas.removeEventListener('touchend', this._handleTouchEnd);\\n      };\\n      SignaturePad.prototype.isEmpty = function () {\\n          return this._isEmpty;\\n      };\\n      SignaturePad.prototype.fromData = function (pointGroups, suppressClear = false) {\\n        var _this = this;\\n        if (!suppressClear) this.clear();\\n        if (pointGroups && pointGroups.length > 0) {\\n          this._fromData(\\n            pointGroups,\\n            ({ color, curve }) => _this._drawCurve({ color, curve }),\\n            ({ color, point, dotSize }) => _this._drawDot({ color, point, dotSize })\\n          );\\n          this._data = pointGroups;\\n        }\\n      };\\n      SignaturePad.prototype.toData = function () {\\n          return this._data;\\n      };\\n      SignaturePad.prototype._strokeBegin = function (event) {\\n        var newPointGroup = {\\n          color: this.penColor,\\n          dotSize: typeof this.dotSize === 'function' ? this.dotSize() : this.dotSize,\\n          minWidth: this.minWidth,\\n          maxWidth: this.maxWidth,\\n          compositeOperation: this._ctx.globalCompositeOperation,\\n          points: [],\\n        };\\n        if (typeof this.onBegin === \\\"function\\\") {\\n          this.onBegin(event);\\n        }\\n        this._data.push(newPointGroup);\\n        this._history = [];\\n        this._reset();\\n        this._strokeUpdate(event);\\n      };\\n      SignaturePad.prototype._strokeUpdate = function (event) {\\n          var x = event.clientX;\\n          var y = event.clientY;\\n          var point = this._createPoint(x, y);\\n          var lastPointGroup = this._data[this._data.length - 1];\\n          var lastPoints = lastPointGroup.points;\\n          var lastPoint = lastPoints.length > 0 && lastPoints[lastPoints.length - 1];\\n          var isLastPointTooClose = lastPoint\\n              ? point.distanceTo(lastPoint) <= this.minDistance\\n              : false;\\n          var color = lastPointGroup.color;\\n          if (!lastPoint || !(lastPoint && isLastPointTooClose)) {\\n              var curve = this._addPoint(point);\\n              if (!lastPoint) {\\n                  this._drawDot({ color, point });\\n              }\\n              else if (curve) {\\n                  this._drawCurve({ color, curve });\\n              }\\n              lastPoints.push({\\n                  time: point.time,\\n                  x: point.x,\\n                  y: point.y\\n              });\\n          }\\n      };\\n      SignaturePad.prototype._strokeEnd = function (event) {\\n          this._strokeUpdate(event);\\n          if (typeof this.onEnd === 'function') {\\n              this.onEnd(event);\\n          }\\n      };\\n      SignaturePad.prototype._handlePointerEvents = function () {\\n          this._mouseButtonDown = false;\\n          this.canvas.addEventListener('pointerdown', this._handleMouseDown);\\n          this.canvas.addEventListener('pointermove', this._handleMouseMove);\\n          document.addEventListener('pointerup', this._handleMouseUp);\\n      };\\n      SignaturePad.prototype._handleMouseEvents = function () {\\n          this._mouseButtonDown = false;\\n          this.canvas.addEventListener('mousedown', this._handleMouseDown);\\n          this.canvas.addEventListener('mousemove', this._handleMouseMove);\\n          document.addEventListener('mouseup', this._handleMouseUp);\\n      };\\n      SignaturePad.prototype._handleTouchEvents = function () {\\n          this.canvas.addEventListener('touchstart', this._handleTouchStart);\\n          this.canvas.addEventListener('touchmove', this._handleTouchMove);\\n          this.canvas.addEventListener('touchend', this._handleTouchEnd);\\n      };\\n      SignaturePad.prototype._reset = function () {\\n          this._lastPoints = [];\\n          this._lastVelocity = 0;\\n          this._lastWidth = typeof this.dotSize === 'function' ? this.dotSize() : this.dotSize;\\n          this._ctx.fillStyle = this.penColor;\\n      };\\n      SignaturePad.prototype._createPoint = function (x, y) {\\n          var rect = this.canvas.getBoundingClientRect();\\n          if (<%orientation%>) {\\n            return new Point(y - rect.top, rect.left+rect.width-x, new Date().getTime());\\n          } else {\\n            return new Point(x - rect.left, y - rect.top, new Date().getTime());\\n          }\\n      };\\n      SignaturePad.prototype._addPoint = function (point, minWidth = this.minWidth, maxWidth = this.maxWidth) {\\n          var _lastPoints = this._lastPoints;\\n          _lastPoints.push(point);\\n          if (_lastPoints.length > 2) {\\n              if (_lastPoints.length === 3) {\\n                  _lastPoints.unshift(_lastPoints[0]);\\n              }\\n              var widths = this._calculateCurveWidths(_lastPoints[1], _lastPoints[2], minWidth, maxWidth);\\n              var curve = Bezier.fromPoints(_lastPoints, widths);\\n              _lastPoints.shift();\\n              return curve;\\n          }\\n          return null;\\n      };\\n      SignaturePad.prototype._calculateCurveWidths = function (startPoint, endPoint, minWidth = this.minWidth, maxWidth = this.maxWidth) {\\n          var velocity = this.velocityFilterWeight * endPoint.velocityFrom(startPoint) +\\n              (1 - this.velocityFilterWeight) * this._lastVelocity;\\n          var newWidth = this._strokeWidth(velocity, minWidth, maxWidth);\\n          var widths = {\\n              end: newWidth,\\n              start: this._lastWidth\\n          };\\n          this._lastVelocity = velocity;\\n          this._lastWidth = newWidth;\\n          return widths;\\n      };\\n      SignaturePad.prototype._strokeWidth = function (velocity, minWidth = this.minWidth, maxWidth = this.maxWidth) {\\n          return Math.max(maxWidth / (velocity + 1), minWidth);\\n      };\\n      SignaturePad.prototype._drawCurveSegment = function (x, y, width) {\\n          var ctx = this._ctx;\\n          ctx.moveTo(x, y);\\n          ctx.arc(x, y, width, 0, 2 * Math.PI, false);\\n          this._isEmpty = false;\\n      };\\n      SignaturePad.prototype._drawCurve = function (_a) {\\n          var color = _a.color, curve = _a.curve;\\n          var ctx = this._ctx;\\n          var widthDelta = curve.endWidth - curve.startWidth;\\n          var drawSteps = Math.floor(curve.length()) * 2;\\n          ctx.beginPath();\\n          ctx.fillStyle = color;\\n          for (var i = 0; i < drawSteps; i += 1) {\\n              var t = i / drawSteps;\\n              var tt = t * t;\\n              var ttt = tt * t;\\n              var u = 1 - t;\\n              var uu = u * u;\\n              var uuu = uu * u;\\n              var x = uuu * curve.startPoint.x;\\n              x += 3 * uu * t * curve.control1.x;\\n              x += 3 * u * tt * curve.control2.x;\\n              x += ttt * curve.endPoint.x;\\n              var y = uuu * curve.startPoint.y;\\n              y += 3 * uu * t * curve.control1.y;\\n              y += 3 * u * tt * curve.control2.y;\\n              y += ttt * curve.endPoint.y;\\n              var width = curve.startWidth + ttt * widthDelta;\\n              this._drawCurveSegment(x, y, width);\\n          }\\n          ctx.closePath();\\n          ctx.fill();\\n      };\\n      SignaturePad.prototype._drawDot = function (_a) {\\n        var color = _a.color, point = _a.point;\\n        var ctx = this._ctx;\\n        var width = _a.dotSize ? _a.dotSize : typeof this.dotSize === \\\"function\\\" ? this.dotSize() : this.dotSize;\\n        ctx.beginPath();\\n        this._drawCurveSegment(point.x, point.y, width);\\n        ctx.closePath();\\n        ctx.fillStyle = color;\\n        ctx.fill();\\n      };\\n      SignaturePad.prototype._fromData = function (pointGroups, drawCurve, drawDot) {\\n        for (var i = 0; i < pointGroups.length; i++) {\\n          var group = pointGroups[i];\\n          var color = group.color, points = group.points;\\n          var minWidth = group.minWidth, maxWidth = group.maxWidth, dotSize = group.dotSize;\\n          var compositeOperation = group.compositeOperation;\\n          this._reset();\\n          this._lastWidth = dotSize;\\n          if (points.length > 1) {\\n            for (var j = 0; j < points.length; j++) {\\n              var point = new Point(points[j].x, points[j].y, points[j].time);\\n              this._ctx.globalCompositeOperation = compositeOperation;\\n              var curve = this._addPoint(point, minWidth, maxWidth);\\n              if (curve) drawCurve({ color, curve });\\n            };\\n          } else drawDot({ color, point: points[0], dotSize });\\n        };\\n        this._ctx.globalCompositeOperation = this._isDrawing ? \\\"source-over\\\" : \\\"destination-out\\\";\\n      };\\n      SignaturePad.prototype._toSVG = function () {\\n          var _this = this;\\n          var pointGroups = this._data;\\n          var ratio = Math.max(window.devicePixelRatio || 1, 1);\\n          var minX = 0;\\n          var minY = 0;\\n          var maxX = this.canvas.width / ratio;\\n          var maxY = this.canvas.height / ratio;\\n          var svg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');\\n          svg.setAttribute('width', this.canvas.width.toString());\\n          svg.setAttribute('height', this.canvas.height.toString());\\n          this._fromData(pointGroups, function (_a) {\\n              var color = _a.color, curve = _a.curve;\\n              var path = document.createElement(\\\"path\\\");\\n              if (!isNaN(curve.control1.x) && !isNaN(curve.control1.y) && !isNaN(curve.control2.x) && !isNaN(curve.control2.y)) {\\n                var attr = \\\"M \\\" + curve.startPoint.x.toFixed(3) + \\\",\\\" + curve.startPoint.y.toFixed(3) + \\\" \\\" + (\\\"C \\\" + curve.control1.x.toFixed(3) + \\\",\\\" + curve.control1.y.toFixed(3) + \\\" \\\") + (curve.control2.x.toFixed(3) + \\\",\\\" + curve.control2.y.toFixed(3) + \\\" \\\") + (curve.endPoint.x.toFixed(3) + \\\",\\\" + curve.endPoint.y.toFixed(3));\\n                path.setAttribute(\\\"d\\\", attr);\\n                path.setAttribute(\\\"stroke-width\\\", (curve.endWidth * 2.25).toFixed(3));\\n                path.setAttribute(\\\"stroke\\\", color);\\n                path.setAttribute(\\\"fill\\\", \\\"none\\\");\\n                path.setAttribute(\\\"stroke-linecap\\\", \\\"round\\\");\\n                svg.appendChild(path);\\n              }\\n            },\\n            function (_a) {\\n              var color = _a.color,point = _a.point;\\n              var circle = document.createElement(\\\"circle\\\");\\n              var dotSize = _a.dotSize ? _a.dotSize : typeof _this.dotSize === \\\"function\\\" ? _this.dotSize() : _this.dotSize;\\n              circle.setAttribute(\\\"r\\\", dotSize.toString());\\n              circle.setAttribute(\\\"cx\\\", point.x.toString());\\n              circle.setAttribute(\\\"cy\\\", point.y.toString());\\n              circle.setAttribute(\\\"fill\\\", color);\\n              svg.appendChild(circle);\\n            }\\n          );\\n          var prefix = 'data:image/svg+xml;base64,';\\n          var header = '<svg' +\\n              ' xmlns=\\\"http://www.w3.org/2000/svg\\\"' +\\n              ' xmlns:xlink=\\\"http://www.w3.org/1999/xlink\\\"' +\\n              (\\\" viewBox=\\\\\\\"\\\" + minX + \\\" \\\" + minY + \\\" \\\" + maxX + \\\" \\\" + maxY + \\\"\\\\\\\"\\\") +\\n              (\\\" width=\\\\\\\"\\\" + maxX + \\\"\\\\\\\"\\\") +\\n              (\\\" height=\\\\\\\"\\\" + maxY + \\\"\\\\\\\"\\\") +\\n              '>';\\n          var body = svg.innerHTML;\\n          if (body === undefined) {\\n              var dummy = document.createElement('dummy');\\n              var nodes = svg.childNodes;\\n              dummy.innerHTML = '';\\n              for (var i = 0; i < nodes.length; i += 1) {\\n                  dummy.appendChild(nodes[i].cloneNode(true));\\n              }\\n              body = dummy.innerHTML;\\n          }\\n          var footer = '</svg>';\\n          var data = header + body + footer;\\n          return prefix + btoa(data);\\n      };\\n      return SignaturePad;\\n  }());\\n\\n  return SignaturePad;\\n\\n})));\\n\";",
	"map": {
		"version": 3,
		"sources": [
			"/Users/llh/Documents/map/frontend/node_modules/react-native-signature-canvas/h5/js/signature_pad.js"
		],
		"names": [],
		"mappings": "AAAA",
		"sourcesContent": [
			"export default `\n/*!\n * Signature Pad v3.0.0-beta.3 | https://github.com/szimek/signature_pad\n * (c) 2018 Szymon Nowak | Released under the MIT license\n */\n\n(function (global, factory) {\n  typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() :\n  typeof define === 'function' && define.amd ? define(factory) :\n  (global.SignaturePad = factory());\n}(this, (function () { 'use strict';\n\n  var Point = (function () {\n      function Point(x, y, time) {\n          this.x = x;\n          this.y = y;\n          this.time = time || Date.now();\n      }\n      Point.prototype.distanceTo = function (start) {\n          return Math.sqrt(Math.pow(this.x - start.x, 2) + Math.pow(this.y - start.y, 2));\n      };\n      Point.prototype.equals = function (other) {\n          return this.x === other.x && this.y === other.y && this.time === other.time;\n      };\n      Point.prototype.velocityFrom = function (start) {\n          return this.time !== start.time\n              ? this.distanceTo(start) / (this.time - start.time)\n              : 0;\n      };\n      return Point;\n  }());\n\n  var Bezier = (function () {\n      function Bezier(startPoint, control2, control1, endPoint, startWidth, endWidth) {\n          this.startPoint = startPoint;\n          this.control2 = control2;\n          this.control1 = control1;\n          this.endPoint = endPoint;\n          this.startWidth = startWidth;\n          this.endWidth = endWidth;\n      }\n      Bezier.fromPoints = function (points, widths) {\n          var c2 = this.calculateControlPoints(points[0], points[1], points[2]).c2;\n          var c3 = this.calculateControlPoints(points[1], points[2], points[3]).c1;\n          return new Bezier(points[1], c2, c3, points[2], widths.start, widths.end);\n      };\n      Bezier.calculateControlPoints = function (s1, s2, s3) {\n          var dx1 = s1.x - s2.x;\n          var dy1 = s1.y - s2.y;\n          var dx2 = s2.x - s3.x;\n          var dy2 = s2.y - s3.y;\n          var m1 = { x: (s1.x + s2.x) / 2.0, y: (s1.y + s2.y) / 2.0 };\n          var m2 = { x: (s2.x + s3.x) / 2.0, y: (s2.y + s3.y) / 2.0 };\n          var l1 = Math.sqrt(dx1 * dx1 + dy1 * dy1);\n          var l2 = Math.sqrt(dx2 * dx2 + dy2 * dy2);\n          var dxm = m1.x - m2.x;\n          var dym = m1.y - m2.y;\n          var k = l2 / (l1 + l2);\n          var cm = { x: m2.x + dxm * k, y: m2.y + dym * k };\n          var tx = s2.x - cm.x;\n          var ty = s2.y - cm.y;\n          return {\n              c1: new Point(m1.x + tx, m1.y + ty),\n              c2: new Point(m2.x + tx, m2.y + ty)\n          };\n      };\n      Bezier.prototype.length = function () {\n          var steps = 10;\n          var length = 0;\n          var px;\n          var py;\n          for (var i = 0; i <= steps; i += 1) {\n              var t = i / steps;\n              var cx = this.point(t, this.startPoint.x, this.control1.x, this.control2.x, this.endPoint.x);\n              var cy = this.point(t, this.startPoint.y, this.control1.y, this.control2.y, this.endPoint.y);\n              if (i > 0) {\n                  var xdiff = cx - px;\n                  var ydiff = cy - py;\n                  length += Math.sqrt(xdiff * xdiff + ydiff * ydiff);\n              }\n              px = cx;\n              py = cy;\n          }\n          return length;\n      };\n      Bezier.prototype.point = function (t, start, c1, c2, end) {\n          return (start * (1.0 - t) * (1.0 - t) * (1.0 - t))\n              + (3.0 * c1 * (1.0 - t) * (1.0 - t) * t)\n              + (3.0 * c2 * (1.0 - t) * t * t)\n              + (end * t * t * t);\n      };\n      return Bezier;\n  }());\n\n  function throttle(fn, wait) {\n      if (wait === void 0) { wait = 250; }\n      var previous = 0;\n      var timeout = null;\n      var result;\n      var storedContext;\n      var storedArgs;\n      var later = function () {\n          previous = Date.now();\n          timeout = null;\n          result = fn.apply(storedContext, storedArgs);\n          if (!timeout) {\n              storedContext = null;\n              storedArgs = [];\n          }\n      };\n      return function wrapper() {\n          var args = [];\n          for (var _i = 0; _i < arguments.length; _i++) {\n              args[_i] = arguments[_i];\n          }\n          var now = Date.now();\n          var remaining = wait - (now - previous);\n          storedContext = this;\n          storedArgs = args;\n          if (remaining <= 0 || remaining > wait) {\n              if (timeout) {\n                  clearTimeout(timeout);\n                  timeout = null;\n              }\n              previous = now;\n              result = fn.apply(storedContext, storedArgs);\n              if (!timeout) {\n                  storedContext = null;\n                  storedArgs = [];\n              }\n          }\n          else if (!timeout) {\n              timeout = window.setTimeout(later, remaining);\n          }\n          return result;\n      };\n  }\n\n  var SignaturePad = (function () {\n      function SignaturePad(canvas, options) {\n          if (options === void 0) options = {};\n          var _this = this;\n          this.canvas = canvas;\n          this.options = options;\n          this._startingSignature = null;\n          this._isDrawing = true;\n          this._history = [];\n          this._handleMouseDown = function (event) {\n              if (event.which === 1) {\n                  _this._mouseButtonDown = true;\n                  _this._strokeBegin(event);\n              }\n          };\n          this._handleMouseMove = function (event) {\n              if (_this._mouseButtonDown) {\n                  _this._strokeMoveUpdate(event);\n              }\n          };\n          this._handleMouseUp = function (event) {\n              if (event.which === 1 && _this._mouseButtonDown) {\n                  _this._mouseButtonDown = false;\n                  _this._strokeEnd(event);\n              }\n          };\n          this._handleTouchStart = function (event) {\n              event.preventDefault();\n              if (event.targetTouches.length === 1) {\n                  var touch = event.changedTouches[0];\n                  _this._strokeBegin(touch);\n              }\n          };\n          this._handleTouchMove = function (event) {\n              event.preventDefault();\n              var touch = event.targetTouches[0];\n              _this._strokeMoveUpdate(touch);\n          };\n          this._handleTouchEnd = function (event) {\n              var wasCanvasTouched = event.target === _this.canvas;\n              if (wasCanvasTouched) {\n                  event.preventDefault();\n                  var touch = event.changedTouches[0];\n                  _this._strokeEnd(touch);\n              }\n          };\n          this.velocityFilterWeight = options.velocityFilterWeight || 0.7;\n          this.minWidth = options.minWidth || 0.5;\n          this.maxWidth = options.maxWidth || 2.5;\n          this.throttle = \"throttle\" in options ? options.throttle : 16;\n          this.minDistance = \"minDistance\" in options ? options.minDistance : 5;\n          this._strokeMoveUpdate = this.throttle\n            ? (this._strokeMoveUpdate = throttle(\n                SignaturePad.prototype._strokeUpdate,\n                this.throttle\n              ))\n            : SignaturePad.prototype._strokeUpdate;\n          this.dotSize = options.dotSize || function dotSize() {return (this.minWidth + this.maxWidth) / 2;};\n          this.penColor = options.penColor || \"black\";\n          this.backgroundColor = options.backgroundColor || \"rgba(255,255,255,0)\";\n          this.onBegin = options.onBegin;\n          this.onEnd = options.onEnd;\n          this._ctx = canvas.getContext(\"2d\");\n          this.clear();\n          this.on();\n      }\n      SignaturePad.prototype.clear = function () {\n          var ctx = this._ctx;\n          var canvas = this.canvas;\n          ctx.fillStyle = this.backgroundColor;\n          ctx.clearRect(0, 0, canvas.width, canvas.height);\n          ctx.fillRect(0, 0, canvas.width, canvas.height);\n          this._data = [];\n          this._reset();\n          this._isEmpty = true;\n      };\n      SignaturePad.prototype.undo = function () {\n        const data = this.toData();\n        if (data && data.length) {\n            this._history.push(data.pop()); // remove the last stroke\n        } else if (this._startingSignature) {\n            return; // they performed undo of background sig\n        }\n        this.clear();\n        if (this._startingSignature) {\n            this.fromDataURL(this._startingSignature, {}, () => this.fromData(data, true));\n        } else {\n            this.fromData(data, true);\n        }\n      };\n      SignaturePad.prototype.redo = function () {\n        if (!this._history.length) return;\n        const data = this.toData();\n        data.push(this._history.pop());\n        this.clear();\n        if (this._startingSignature) {\n            this.fromDataURL(this._startingSignature, {}, () => this.fromData(data, true));\n        } else {\n            this.fromData(data, true);\n        }\n      };\n      SignaturePad.prototype.draw = function () {\n        this._ctx.globalCompositeOperation = \"source-over\";\n        this._isDrawing = true;\n      };\n      SignaturePad.prototype.erase = function () {\n        this._ctx.globalCompositeOperation = \"destination-out\";\n        this._isDrawing = false;\n      };\n      SignaturePad.prototype.fromDataURL = function (dataUrl, options, callback) {\n          var _this = this;\n          if (options === void 0) options = {};\n          var image = new Image();\n          var ratio = options.ratio || window.devicePixelRatio || 1;\n          var width = options.width || this.canvas.width / ratio;\n          var height = options.height || this.canvas.height / ratio;\n          this._reset();\n          image.src = dataUrl;\n          image.onload = function () {\n            _this._ctx.globalCompositeOperation = \"source-over\";\n            _this._ctx.drawImage(image, 0, 0, width, height);\n            _this._ctx.globalCompositeOperation = _this._isDrawing ? \"source-over\" : \"destination-out\";\n              if (callback) {\n                  callback();\n              }\n          };\n          image.onerror = function (error) {\n              if (callback) {\n                  callback(error);\n              }\n          };\n          this._isEmpty = false;\n          if (!this._startingSignature) this._startingSignature = dataUrl;\n      };\n      SignaturePad.prototype.toDataURL = function (type = \"image/png\", encoderOptions) {\n        return type === \"image/svg+xml\" ? this._toSVG() : this.canvas.toDataURL(type, encoderOptions);\n      };\n      SignaturePad.prototype.on = function () {\n          this.canvas.style.touchAction = 'none';\n          this.canvas.style.msTouchAction = 'none';\n          if (window.PointerEvent) {\n              this._handlePointerEvents();\n          }\n          else {\n              this._handleMouseEvents();\n              if ('ontouchstart' in window) {\n                  this._handleTouchEvents();\n              }\n          }\n      };\n      SignaturePad.prototype.off = function () {\n          this.canvas.style.touchAction = 'auto';\n          this.canvas.style.msTouchAction = 'auto';\n          this.canvas.removeEventListener('pointerdown', this._handleMouseDown);\n          this.canvas.removeEventListener('pointermove', this._handleMouseMove);\n          document.removeEventListener('pointerup', this._handleMouseUp);\n          this.canvas.removeEventListener('mousedown', this._handleMouseDown);\n          this.canvas.removeEventListener('mousemove', this._handleMouseMove);\n          document.removeEventListener('mouseup', this._handleMouseUp);\n          this.canvas.removeEventListener('touchstart', this._handleTouchStart);\n          this.canvas.removeEventListener('touchmove', this._handleTouchMove);\n          this.canvas.removeEventListener('touchend', this._handleTouchEnd);\n      };\n      SignaturePad.prototype.isEmpty = function () {\n          return this._isEmpty;\n      };\n      SignaturePad.prototype.fromData = function (pointGroups, suppressClear = false) {\n        var _this = this;\n        if (!suppressClear) this.clear();\n        if (pointGroups && pointGroups.length > 0) {\n          this._fromData(\n            pointGroups,\n            ({ color, curve }) => _this._drawCurve({ color, curve }),\n            ({ color, point, dotSize }) => _this._drawDot({ color, point, dotSize })\n          );\n          this._data = pointGroups;\n        }\n      };\n      SignaturePad.prototype.toData = function () {\n          return this._data;\n      };\n      SignaturePad.prototype._strokeBegin = function (event) {\n        var newPointGroup = {\n          color: this.penColor,\n          dotSize: typeof this.dotSize === 'function' ? this.dotSize() : this.dotSize,\n          minWidth: this.minWidth,\n          maxWidth: this.maxWidth,\n          compositeOperation: this._ctx.globalCompositeOperation,\n          points: [],\n        };\n        if (typeof this.onBegin === \"function\") {\n          this.onBegin(event);\n        }\n        this._data.push(newPointGroup);\n        this._history = [];\n        this._reset();\n        this._strokeUpdate(event);\n      };\n      SignaturePad.prototype._strokeUpdate = function (event) {\n          var x = event.clientX;\n          var y = event.clientY;\n          var point = this._createPoint(x, y);\n          var lastPointGroup = this._data[this._data.length - 1];\n          var lastPoints = lastPointGroup.points;\n          var lastPoint = lastPoints.length > 0 && lastPoints[lastPoints.length - 1];\n          var isLastPointTooClose = lastPoint\n              ? point.distanceTo(lastPoint) <= this.minDistance\n              : false;\n          var color = lastPointGroup.color;\n          if (!lastPoint || !(lastPoint && isLastPointTooClose)) {\n              var curve = this._addPoint(point);\n              if (!lastPoint) {\n                  this._drawDot({ color, point });\n              }\n              else if (curve) {\n                  this._drawCurve({ color, curve });\n              }\n              lastPoints.push({\n                  time: point.time,\n                  x: point.x,\n                  y: point.y\n              });\n          }\n      };\n      SignaturePad.prototype._strokeEnd = function (event) {\n          this._strokeUpdate(event);\n          if (typeof this.onEnd === 'function') {\n              this.onEnd(event);\n          }\n      };\n      SignaturePad.prototype._handlePointerEvents = function () {\n          this._mouseButtonDown = false;\n          this.canvas.addEventListener('pointerdown', this._handleMouseDown);\n          this.canvas.addEventListener('pointermove', this._handleMouseMove);\n          document.addEventListener('pointerup', this._handleMouseUp);\n      };\n      SignaturePad.prototype._handleMouseEvents = function () {\n          this._mouseButtonDown = false;\n          this.canvas.addEventListener('mousedown', this._handleMouseDown);\n          this.canvas.addEventListener('mousemove', this._handleMouseMove);\n          document.addEventListener('mouseup', this._handleMouseUp);\n      };\n      SignaturePad.prototype._handleTouchEvents = function () {\n          this.canvas.addEventListener('touchstart', this._handleTouchStart);\n          this.canvas.addEventListener('touchmove', this._handleTouchMove);\n          this.canvas.addEventListener('touchend', this._handleTouchEnd);\n      };\n      SignaturePad.prototype._reset = function () {\n          this._lastPoints = [];\n          this._lastVelocity = 0;\n          this._lastWidth = typeof this.dotSize === 'function' ? this.dotSize() : this.dotSize;\n          this._ctx.fillStyle = this.penColor;\n      };\n      SignaturePad.prototype._createPoint = function (x, y) {\n          var rect = this.canvas.getBoundingClientRect();\n          if (<%orientation%>) {\n            return new Point(y - rect.top, rect.left+rect.width-x, new Date().getTime());\n          } else {\n            return new Point(x - rect.left, y - rect.top, new Date().getTime());\n          }\n      };\n      SignaturePad.prototype._addPoint = function (point, minWidth = this.minWidth, maxWidth = this.maxWidth) {\n          var _lastPoints = this._lastPoints;\n          _lastPoints.push(point);\n          if (_lastPoints.length > 2) {\n              if (_lastPoints.length === 3) {\n                  _lastPoints.unshift(_lastPoints[0]);\n              }\n              var widths = this._calculateCurveWidths(_lastPoints[1], _lastPoints[2], minWidth, maxWidth);\n              var curve = Bezier.fromPoints(_lastPoints, widths);\n              _lastPoints.shift();\n              return curve;\n          }\n          return null;\n      };\n      SignaturePad.prototype._calculateCurveWidths = function (startPoint, endPoint, minWidth = this.minWidth, maxWidth = this.maxWidth) {\n          var velocity = this.velocityFilterWeight * endPoint.velocityFrom(startPoint) +\n              (1 - this.velocityFilterWeight) * this._lastVelocity;\n          var newWidth = this._strokeWidth(velocity, minWidth, maxWidth);\n          var widths = {\n              end: newWidth,\n              start: this._lastWidth\n          };\n          this._lastVelocity = velocity;\n          this._lastWidth = newWidth;\n          return widths;\n      };\n      SignaturePad.prototype._strokeWidth = function (velocity, minWidth = this.minWidth, maxWidth = this.maxWidth) {\n          return Math.max(maxWidth / (velocity + 1), minWidth);\n      };\n      SignaturePad.prototype._drawCurveSegment = function (x, y, width) {\n          var ctx = this._ctx;\n          ctx.moveTo(x, y);\n          ctx.arc(x, y, width, 0, 2 * Math.PI, false);\n          this._isEmpty = false;\n      };\n      SignaturePad.prototype._drawCurve = function (_a) {\n          var color = _a.color, curve = _a.curve;\n          var ctx = this._ctx;\n          var widthDelta = curve.endWidth - curve.startWidth;\n          var drawSteps = Math.floor(curve.length()) * 2;\n          ctx.beginPath();\n          ctx.fillStyle = color;\n          for (var i = 0; i < drawSteps; i += 1) {\n              var t = i / drawSteps;\n              var tt = t * t;\n              var ttt = tt * t;\n              var u = 1 - t;\n              var uu = u * u;\n              var uuu = uu * u;\n              var x = uuu * curve.startPoint.x;\n              x += 3 * uu * t * curve.control1.x;\n              x += 3 * u * tt * curve.control2.x;\n              x += ttt * curve.endPoint.x;\n              var y = uuu * curve.startPoint.y;\n              y += 3 * uu * t * curve.control1.y;\n              y += 3 * u * tt * curve.control2.y;\n              y += ttt * curve.endPoint.y;\n              var width = curve.startWidth + ttt * widthDelta;\n              this._drawCurveSegment(x, y, width);\n          }\n          ctx.closePath();\n          ctx.fill();\n      };\n      SignaturePad.prototype._drawDot = function (_a) {\n        var color = _a.color, point = _a.point;\n        var ctx = this._ctx;\n        var width = _a.dotSize ? _a.dotSize : typeof this.dotSize === \"function\" ? this.dotSize() : this.dotSize;\n        ctx.beginPath();\n        this._drawCurveSegment(point.x, point.y, width);\n        ctx.closePath();\n        ctx.fillStyle = color;\n        ctx.fill();\n      };\n      SignaturePad.prototype._fromData = function (pointGroups, drawCurve, drawDot) {\n        for (var i = 0; i < pointGroups.length; i++) {\n          var group = pointGroups[i];\n          var color = group.color, points = group.points;\n          var minWidth = group.minWidth, maxWidth = group.maxWidth, dotSize = group.dotSize;\n          var compositeOperation = group.compositeOperation;\n          this._reset();\n          this._lastWidth = dotSize;\n          if (points.length > 1) {\n            for (var j = 0; j < points.length; j++) {\n              var point = new Point(points[j].x, points[j].y, points[j].time);\n              this._ctx.globalCompositeOperation = compositeOperation;\n              var curve = this._addPoint(point, minWidth, maxWidth);\n              if (curve) drawCurve({ color, curve });\n            };\n          } else drawDot({ color, point: points[0], dotSize });\n        };\n        this._ctx.globalCompositeOperation = this._isDrawing ? \"source-over\" : \"destination-out\";\n      };\n      SignaturePad.prototype._toSVG = function () {\n          var _this = this;\n          var pointGroups = this._data;\n          var ratio = Math.max(window.devicePixelRatio || 1, 1);\n          var minX = 0;\n          var minY = 0;\n          var maxX = this.canvas.width / ratio;\n          var maxY = this.canvas.height / ratio;\n          var svg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');\n          svg.setAttribute('width', this.canvas.width.toString());\n          svg.setAttribute('height', this.canvas.height.toString());\n          this._fromData(pointGroups, function (_a) {\n              var color = _a.color, curve = _a.curve;\n              var path = document.createElement(\"path\");\n              if (!isNaN(curve.control1.x) && !isNaN(curve.control1.y) && !isNaN(curve.control2.x) && !isNaN(curve.control2.y)) {\n                var attr = \"M \" + curve.startPoint.x.toFixed(3) + \",\" + curve.startPoint.y.toFixed(3) + \" \" + (\"C \" + curve.control1.x.toFixed(3) + \",\" + curve.control1.y.toFixed(3) + \" \") + (curve.control2.x.toFixed(3) + \",\" + curve.control2.y.toFixed(3) + \" \") + (curve.endPoint.x.toFixed(3) + \",\" + curve.endPoint.y.toFixed(3));\n                path.setAttribute(\"d\", attr);\n                path.setAttribute(\"stroke-width\", (curve.endWidth * 2.25).toFixed(3));\n                path.setAttribute(\"stroke\", color);\n                path.setAttribute(\"fill\", \"none\");\n                path.setAttribute(\"stroke-linecap\", \"round\");\n                svg.appendChild(path);\n              }\n            },\n            function (_a) {\n              var color = _a.color,point = _a.point;\n              var circle = document.createElement(\"circle\");\n              var dotSize = _a.dotSize ? _a.dotSize : typeof _this.dotSize === \"function\" ? _this.dotSize() : _this.dotSize;\n              circle.setAttribute(\"r\", dotSize.toString());\n              circle.setAttribute(\"cx\", point.x.toString());\n              circle.setAttribute(\"cy\", point.y.toString());\n              circle.setAttribute(\"fill\", color);\n              svg.appendChild(circle);\n            }\n          );\n          var prefix = 'data:image/svg+xml;base64,';\n          var header = '<svg' +\n              ' xmlns=\"http://www.w3.org/2000/svg\"' +\n              ' xmlns:xlink=\"http://www.w3.org/1999/xlink\"' +\n              (\" viewBox=\\\\\"\" + minX + \" \" + minY + \" \" + maxX + \" \" + maxY + \"\\\\\"\") +\n              (\" width=\\\\\"\" + maxX + \"\\\\\"\") +\n              (\" height=\\\\\"\" + maxY + \"\\\\\"\") +\n              '>';\n          var body = svg.innerHTML;\n          if (body === undefined) {\n              var dummy = document.createElement('dummy');\n              var nodes = svg.childNodes;\n              dummy.innerHTML = '';\n              for (var i = 0; i < nodes.length; i += 1) {\n                  dummy.appendChild(nodes[i].cloneNode(true));\n              }\n              body = dummy.innerHTML;\n          }\n          var footer = '</svg>';\n          var data = header + body + footer;\n          return prefix + btoa(data);\n      };\n      return SignaturePad;\n  }());\n\n  return SignaturePad;\n\n})));\n`;\n"
		]
	},
	"metadata": {},
	"sourceType": "module"
}
